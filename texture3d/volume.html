<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script id="vs" type="x-shader/x-vertex">
#version 300 es
#define POSITION_LOCATION 0
#define TEXCOORD_LOCATION 4

precision highp float;
precision highp int;

uniform mat4 MVP;

layout(location = POSITION_LOCATION) in vec2 position;
layout(location = TEXCOORD_LOCATION) in vec2 texcoord;

out vec2 v_st;

void main()
{
    v_st = texcoord;
    gl_Position = MVP * vec4(position, 0.0, 1.0);
}
</script>
<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;
precision highp int;
precision highp sampler2DArray;

uniform sampler2DArray diffuse;
uniform int layer;

in vec2 v_st;

out vec4 color;

void main()
{
    color = texture(diffuse, vec3(v_st, layer));
}
</script>
<script src="./gl-matrix.js"></script>
<script src="./signals.js"></script>
<script src="./auxiliary.js"></script>
</head>
<body>
    <canvas id="demo" width="400" height="400"></canvas>
    <script>

        let myevent = {
            loadtex: new signals.Signal()
        }
        let canvas = document.getElementById('demo');
        let gl = canvas.getContext( 'webgl2', { antialias: true } )
        if( gl == null ) { alert( 'requires webgl2 support!' ) }

        let render = new mqRender(gl);
        let glsl = new mqShader();
        glsl.vs = glsl.createShader(gl, glsl.getCodeFromElement('vs'), gl.VERTEX_SHADER);
        glsl.fs = glsl.createShader(gl, glsl.getCodeFromElement('fs'), gl.FRAGMENT_SHADER);
        glsl.program = glsl.createProgram(gl, glsl.vs, glsl.fs);
        let attrArray = ['position', 'texcoord'];
        let uniformArray = ['MVP', 'diffuse', 'layer'];
        glsl.bindLocation(gl, attrArray, uniformArray);
                
        // vertex position buffer 
        var positions = new Float32Array([
            -1.0, -1.0,
            1.0, -1.0,
            1.0, 1.0,
            1.0, 1.0,
            -1.0, 1.0,
            -1.0, -1.0
        ]);
        glsl.posbuffer = glsl.bufferData(gl, positions, gl.STATIC_DRAW);

        // texture coordinate buffer
        var texCoords = new Float32Array([
            0.0, 1.0,
            1.0, 1.0,
            1.0, 0.0,
            1.0, 0.0,
            0.0, 0.0,
            0.0, 1.0
        ]);
        glsl.texbuffer = glsl.bufferData(gl, texCoords, gl.STATIC_DRAW);
        glsl.texloc = 4;
        glsl.posloc = 0;
        glsl.createVAO(gl, 'position', 'texcoord');
        
        myevent.loadtex.add(work_render);

        loadImage('/texture3d/test272.jpeg', function(img) {
            render.loadTextureArray(img, 400, 16, 17);
            myevent.loadtex.dispatch(16*17);
        });
                
        function work_render(totalFrame) {   
                     
            gl.useProgram(glsl.program);
            gl.bindVertexArray(glsl.vao);
            
            glsl.enableAttr(gl, 'position', true);
            glsl.enableAttr(gl, 'texcoord', true);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D_ARRAY, render.texVolume);

            var matrix = new Float32Array([
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0
            ]);
            gl.uniformMatrix4fv(glsl.getUniformLoc('MVP'), false, matrix);
            gl.uniform1i(glsl.getUniformLoc('diffuse'), 0);
            
            var frame = 0;
            (function render() {
                // -- Render
                gl.clearColor(1.0, 1.0, 1.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.uniform1i(glsl.getUniformLoc('layer'), frame);
                
                frame = (frame + 1) % totalFrame;
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                setTimeout( function(){
                    requestAnimationFrame(render);
                }, 200);
            })();
        }
    
    </script>        
</body>
</html>