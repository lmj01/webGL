<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script id="vs" type="x-shader/x-vertex">#version 300 es
uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
in vec4 position;
in vec2 uv;
out vec2 vUv;
void main()
{
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * position;
}
</script>
<script id="fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;
precision highp sampler3D;

uniform float lutSize;
uniform sampler2D tDiffuse;
uniform sampler3D tLookup;
uniform bool enabled;

in vec2 vUv;
out vec4 fragColor;
void main() 
{
    vec4 rawColor = texture(tDiffuse, vUv);
    if (enabled) {
        vec3 scale = vec3((lutSize - 1.0) / lutSize);
        vec3 offset = vec3(1.0 / (2.0 * lutSize));
        fragColor.rgb = texture(tLookup, scale * rawColor.rgb + offset).rgb;
        fragColor.a = rawColor.a;
    } else {
        fragColor = rawColor;
    }
}
</script>
</head>
<body>
    <img id="id_img" width="100" height="100" src="./panorama.jpg">
    <canvas id="id_canvas" width="500" height="500" ></canvas>
    <script>
        let canvas = document.getElementById('id_canvas');
        let gl = canvas.getContext( 'webgl2' )
        if( gl == null ) { alert( 'requires webgl2 support!' ) }
    
        let vs_source = document.getElementById('vs').textContent;
        //console.log(vs_source);
        let fs_source = document.getElementById('fs').textContent;
        //console.log(fs_source);
        let vs_shader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs_shader, vs_source);
        gl.compileShader(vs_shader);
        let err_shader = gl.getShaderInfoLog(vs_shader);
        console.log(err_shader);
        let fs_shader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs_shader, fs_source);
        gl.compileShader(fs_shader);
        err_shader = gl.getShaderInfoLog(fs_shader);
        console.log(err_shader);

        var program = gl.createProgram();
        gl.attachShader(program, vs_shader);
        gl.attachShader(program, fs_shader);
        gl.linkProgram(program);
        
        gl.useProgram(program);

        // 2D 纹理
        let uMap = gl.getUniformLocation(program, 'tDiffuse');
        let uVolume = gl.getUniformLocation(program, 'tLookup');
        
        let texture2d = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture2d);
        gl.texImage2D(
            gl.TEXTURE_2D, // target
            0, // level
            gl.RGBA, // 
            gl.RGBA, // 
            gl.UNSIGNED_BYTE,
            document.getElementById('id_img') // data
        );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
        //gl.generateMipmap(gl.TEXTURE_2D);
        
        // 3D纹理需要解析,使用的是Adobe的数据
        loadAdobeLUT('/texture3d/ColorTransform.CUBE', function(texture3d) { 
            
            // 顶点数据
            let vertices = new Float32Array([
                -1.0, 1.0,
                -1.0, -1.0,
                1.0, -1.0,
                1.0, 1.0
            ]);
            let vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            let aPosition = gl.getAttribLocation(program, 'position');
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPosition);

            // 绘制 
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);


        });

        

        
        // parse-cube-lut by thibauts
        // https://github.com/thibauts/parse-cube-lut
        function parseCubeLUT( str ) {

            if (typeof str !== 'string') {
                str = str.toString();
            }

            var title = null;
            var type = null;
            var size = 0;
            var domain = [[0.0, 0.0, 0.0], [1.0, 1.0, 1.0]];
            var data = [];

            var lines = str.split('\n');

            for (var i=0; i<lines.length; i++) {
                var line = lines[i].trim();

                if (line[0] === '#' || line === '') {
                    // skip comments and empty lines
                    continue;
                }

                var parts = line.split(/\s+/);

                switch(parts[0]) {
                    case 'TITLE':
                        title = line.slice(7, -1);
                        break;
                    case 'DOMAIN_MIN':
                        domain[0] = parts.slice(1).map(Number);
                        break;
                    case 'DOMAIN_MAX':
                        domain[1] = parts.slice(1).map(Number);
                        break;
                    case 'LUT_1D_SIZE':
                        type = '1D';
                        size = Number(parts[1]);
                        break;
                    case 'LUT_3D_SIZE':
                        type = '3D';
                        size = Number(parts[1]);
                        break;
                    default: 
                        data.push(parts.map(Number));
                }
            }
            return {
                title: title,
                type: type,
                size: size,
                domain: domain,
                data: data
            };
        }
        function loadAdobeLUT( src ) {
            var texture3d = gl.createTexture();
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture( gl.TEXTURE_3D, texture3d );
            
            var handleComplete = function( e, onComplete ) {
                //console.log('handlecomplete', e);
                var lut = parseCubeLUT(e.target.response);
                if (lut.type !== '3D') throw new Error('expected 3D lut cube type');
                
                var lutData = lut.data;
                var length = lutData.length * 3;
                var size = lut.size;

                if (size * size * size !== lutData.length) {
                    throw new Error('size mismatch with invalid cube lut');
                }

                var float32 = new Float32Array(length);

                for (var k = 0,i=0; i<lutData.length; i++) {
                    for (var j=0;j<3;j++) {
                        var component = lutData[i][j];
                        float32[k++] = component;
                    }
                }

                gl.texImage3D(
                    gl.TEXTURE_3D, // target
                    0, // level
                    gl.RGB16F, // internal format
                    size, // width
                    size, // height 
                    size, // depth 
                    0, // border 
                    gl.RGB16F, // format
                    gl.FLOAT,
                    float32, // array buffer data
                    0, // offset        
                );
            
                gl.texParameteri(
                    gl.TEXTURE_3D,
                    gl.TEXTURE_MAG_FILTER, gl.NEAREST
                );
                gl.texParameteri(
                    gl.TEXTURE_3D,
                    gl.TEXTURE_MIN_FILTER, gl.NEAREST
                );
                gl.texParameteri(
                    gl.TEXTURE_3D,
                    gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE
                );
                gl.texParameteri(
                    gl.TEXTURE_3D,
                    gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE
                );
                gl.texParameteri(
                    gl.TEXTURE_3D,
                    gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE
                );

                if ( onComplete ) onComplete( texture3d );
            }

            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', handleComplete);
            xhr.open('GET', src);
            xhr.send();

        }
        </script>
        
</body>
</html>